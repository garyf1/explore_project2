myInverse <- NULL
# set/ initialize
set <- function(y){
cachedX <<- y
myInverse <<- NULL
}
get <- function() x
setInverse <- function(inverse) myInverse <<- inverse
getInverse <- function() myInverse
#? not sure about this
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
someMatrix < makeCacheMatrix
someMatrix <- makeCacheMatrix
someMatrix$set(vector(1:9,3,3))
aVec <- vector(1:9,3,3)
aVec <- vector(1:9,3,)
>vector
?vector
aMatrix <- Matrix(1:9,3,3)
aMatrix <- matrix(1:9,3,3)
aMatrix
bMatrix <- matrix(1:4,2,2)
bMatrix
someMatrix$set(aMatrix)
someMatrix <- makeCacheMatrix(bMatrix)
makeCacheMatrix <- function(cachedX = matrix()) {
# Create a blank so we are always working against something
myInverse <- NULL
# set/ initialize
set <- function(y){
cachedX <<- y
myInverse <<- NULL
}
get <- function() x
setInverse <- function(inverse) myInverse <<- inverse
getInverse <- function() myInverse
#? not sure about this
#list(set = set, get = get,
#     setmean = setmean,
#     getmean = getmean)
}
someMatrix <- makeCacheMatrix(bMatrix)
someMatrix
someMatrix$get
makeCacheMatrix <- function(cachedX = matrix()) {
# Create a blank so we are always working against something
myInverse <- NULL
# set/ initialize
set <- function(y){
cachedX <<- y
myInverse <<- NULL
}
get <- function() cachedX
setInverse <- function(inverse) myInverse <<- inverse
getInverse <- function() myInverse
#? not sure about this
#list(set = set, get = get,
#     setmean = setmean,
#     getmean = getmean)
}
someMatrix$get
someMatrix <- makeCacheMatrix(bMatrix)
someMatrix$get
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
invX < solve(datum, ...)
x.setInverse(invX)
return(invX)
}
cacheSolve(someMatrix)
cacheSolve(someMatrix)
someMatrix$get()
someMatrix$get
someMatrix$get()
someMatrix
someMatrix$
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
invX < solve(datum, ...)
x$setInverse(invX)
return(invX)
}
cacheSolve(someMatrix)
makeCacheMatrix <- function(cachedX = matrix()) {
# Create a blank so we are always working against something
myInverse <- NULL
# set/ initialize
set <- function(y){
cachedX <<- y
myInverse <<- NULL
}
get <- function() x
setInverse <- function(inverse) myInverse <<- inverse
getInverse <- function() myInverse
#? not sure about this
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
someMatrix <- makeCacheMatrix(bMatrix)
cacheSolve(someMatrix)
aMatrix
bMatrix
makeCacheMatrix <- function(cachedX = matrix()) {
# Create a blank so we are always working against something
myInverse <- NULL
# set/ initialize
set <- function(y){
cachedX <<- y
myInverse <<- NULL
}
get <- function() cachedX
setInverse <- function(inverse) myInverse <<- inverse
getInverse <- function() myInverse
#? not sure about this
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
someMatrix <- makeCacheMatrix(bMatrix)
cacheSolve(someMatrix)
solve(bMatrix)
someMatrix$getInverse
someMatrix$getInverse()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
print datum
invX < solve(datum)
print invX
x$setInverse(invX)
return(invX)
}
solve(bMatrix)
bMatrix
someMatrix$setInverse(solve(bMatrix))
someMatrix$getInvers()
cacheSolve(someMatrix)
garb <- makeCachedMatrix(aMatrix)
garb <- makeCacheMatrix(aMatrix)
garb$getInverse()
cacheSolve(garb)
solve(garb$get())
garb$get()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
solv
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
print datum
print "I printed datum"
invX < solve(datum)
print invX
print "I printed INVx"
x$setInverse(invX)
return(invX)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
solv
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
print( datum)
print( "I printed datum")
invX < solve(datum)
print( invX)
print( "I printed INVx")
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
solve(garb$get())
garb$get()
class(garb$get())
cacheSolve(garb)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
print( datum)
print( "I printed datum")
invX < solve(datum)
print( invX)
print( "I printed INVx")
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
cacheSolve(garb)
aMatric
aMatrix
bMatrix
solve(bMatrix)
garb$get()
cacheSolve(garb)
garb$get()
identical(aMatrix, garb$get())
solve(aMatrix)
aMatrix
garb <- makeCacheMatrix(bMatrix)
garb$get()
cacheSolve(garb)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
invX < solve(datum)
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
cacheSolve(garb)
garb$setInverse(solve(bMatrix))
garb$getInverse()
garb$set(bMatrix)
garb$getInverse()
cacheSolve(garb)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
print(datum)
invX < solve(datum)
print(invX)
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
cacheSolve(garb)
garb$get()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
datum <- x$get()
print("1")
print(datum)
print("2")
print(x$get())
invX < solve(datum)
print(invX)
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
cacheSolve(garb)
solve(bMatrix)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
invX < solve(x$get())
print(invX)
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
solve(bMatrix)
cacheSolve(garb)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Solve for the inverse of x in ix
invX <- x$getInverse()
## check for null (set called, or never calculate)
if(!is.null(invX)){
message("Using the Cached Data")
return(invX)
}
# technically ELSE
message("Calculating the new solve/inverse; setting for X and returning")
invX <- solve(x$get())
print(invX)
x$setInverse(invX)
invX  #I wanted to return(invX) but the system seemed to complain
}
cacheSolve(garb)
garb$getInverse()
install.package("knitr")
package.install("knitr")
install.packages("knitr")
install.packages("manipulate")
myCountNA <- function(myDataFrameVector){
tryCatch(
cntr = 0
stepsIter <- iter(myDataFrameVector, by="row")
while(1==1) {
nxtRow <- nextElem(stepsIter)
if ( is.na(nxtRow$steps) ) {
cntr = cntr + 1
}
},
error = function(e){return cntr}
)
} # Ends the function definitions
myCountNA <- function(myDataFrameVector){
tryCatch(
cntr = 0
stepsIter <- iter(myDataFrameVector, by="row")
while(1==1) {
nxtRow <- nextElem(stepsIter)
if ( is.na(nxtRow$steps) ) {
cntr = cntr + 1
}
return(cntr)
},
error = function(e){return(cntr)}
)
} # Ends the function definitions
install.packages("manipulate")
list.files()
sessionInfo()
library(nlme)
library(lattice)
xyplot(weight ~ Time | Diet, BodyWeight)
library(lattice)
library(datasets)
data(airquality)
p <- xyplot(Ozone ~ Wind | factor(Month), data = airquality)
print(po)
print(p)
library(ggplot2)
g <- ggplot(movies, aes(votes, rating))
print(g)
?qplot
library(datasets)
data(airquality)
qplot(Wind, Ozone, data=airquality, geom="smooth")
library(ggplot2)
qplot(Wind, Ozone, data=airquality, geom="smooth")
airquality=transform(airquality, Month=factor(Month))
qplot(Wind, Ozone, data=airquality, facets = .~Month)
setwd('C:\Users\Gary\Downloads\coursera\explore\project2\git\explore_project2')
NEI <- readRDS("/data/exdata_data_NEI_data/summarySCC_PM25.rds")
SCC <- readRDS("/data/exdata_data_NEI_data/Source_Classification_Code.rds")
setwd('C:/Users/Gary/Downloads/coursera/explore/project2/git/explore_project2')
NEI <- readRDS("/data/exdata_data_NEI_data/summarySCC_PM25.rds")
SCC <- readRDS("/data/exdata_data_NEI_data/Source_Classification_Code.rds")
setwd('C:/Users/Gary/Downloads/coursera/explore/project2/git/explore_project2')
NEI <- readRDS("./data/exdata_data_NEI_data/summarySCC_PM25.rds")
SCC <- readRDS("./data/exdata_data_NEI_data/Source_Classification_Code.rds")
head(NEI)
head(SCC)
library(sqldf)
head(NEI)
rslt = sqldf('select sum(emissions), year from NEI group by year order by year')
rslt
plot(rslt)
rslt2 = sqldf('select sum(emissions), year from NEI where fips = 24510 group by year order by year')
plot(rslt2)
rslt3 = sqldf('select sum(emissions), year, type from NEI where fips = 24510 group by year, type order by year, type')
plot(rslt3)
rslt3
ssc
SCC
SCC$colnames
colnames(SCC)
NEI
png('plot3.png', width=480, height=480)
p <- ggplot(pd, aes(x=year, y=Emissions, colour=type)) +
geom_point(alpha=.3) +
geom_smooth(alpha=.2, size=1, method="loess") +
ggtitle("Total Emissions by Type in Baltimore City")
print(p)
library(ggplot2)
png('plot3.png', width=480, height=480)
p <- ggplot(pd, aes(x=year, y=Emissions, colour=type)) +
geom_point(alpha=.3) +
geom_smooth(alpha=.2, size=1, method="loess") +
ggtitle("Total Emissions by Type in Baltimore City")
print(p)
rslt3 = sqldf('select sum(emissions) as Emissions, year, type from NEI where fips = 24510 group by year, type order by year, type')
plot(rslt3)
library(ggplot2)
png('plot3.png', width=480, height=480)
p <- ggplot(pd, aes(x=year, y=Emissions, colour=type)) +
geom_point(alpha=.3) +
geom_smooth(alpha=.2, size=1, method="loess") +
ggtitle("Baltimore City PM2 Emissions by Type in ")
print(p)
png('plot3.png', width=480, height=480)
p <- ggplot(rslt3, aes(x=year, y=Emissions, colour=type)) +
geom_point(alpha=.3) +
geom_smooth(alpha=.2, size=1, method="loess") +
ggtitle("Baltimore City PM2 Emissions by Type in ")
print(p)
png('plot3.png', width=480, height=480)
rslt3 = sqldf('select sum(emissions) as Emissions, year, type from NEI where fips = 24510 group by year, type order by year, type')
p <- ggplot(rslt3, aes(x=year, y=Emissions, colour=type)) +
geom_point(alpha=.3) +
geom_smooth(alpha=.2, size=1, method="loess") +
ggtitle("Baltimore City PM2 Emissions by Type in ")
p <- ggplot(rslt3, aes(x=year, y=Emissions, colour=type))
geom_point(alpha=.3)
geom_smooth(alpha=.2, size=1, method="loess")
ggtitle("Baltimore City PM2 Emissions by Type in ")
print(p)
png("plot3.png", width=640, height=480)
g <- ggplot(rslt3, aes(year, Emissions, color = type))
g <- g + geom_line() +
xlab("year") +
ylab(expression('Total PM'[2.5]*" Emissions")) +
ggtitle('Total Emissions in Baltimore City, Maryland (fips == "24510") from 1999 to 2008')
print(g)
dev.off()
png("plot3.png", width=640, height=480)
g <- ggplot(rslt3, aes(year, Emissions, color = type))
g <- g + geom_line()
xlab("year")
ylab(expression('Total PM'[2.5]*" Emissions"))
ggtitle('Total Emissions in Baltimore City, Maryland (fips == "24510") from 1999 to 2008')
print(g)
if(!exists("NEISCC")){
NEISCC <- merge(NEI, SCC, by="SCC")
}
subsetNEI <- NEI[(NEI$fips=="24510"|NEI$fips=="06037") & NEI$type=="ON-ROAD", ]
aggregatedTotalByYearAndFips <- aggregate(Emissions ~ year + fips, subsetNEI, sum)
aggregatedTotalByYearAndFips$fips[aggregatedTotalByYearAndFips$fips=="24510"] <- "Baltimore, MD"
aggregatedTotalByYearAndFips$fips[aggregatedTotalByYearAndFips$fips=="06037"] <- "Los Angeles, CA"
png("plot6.png", width=1040, height=480)
g <- ggplot(aggregatedTotalByYearAndFips, aes(factor(year), Emissions))
g <- g + facet_grid(. ~ fips)
g <- g + geom_bar(stat="identity") +
xlab("year") +
ylab(expression('Total PM'[2.5]*" Emissions")) +
ggtitle('Total Emissions from motor vehicle (type=ON-ROAD) in Baltimore City, MD (fips = "24510") vs Los Angeles, CA (fips = "06037") 1999-2008')
print(g)
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
